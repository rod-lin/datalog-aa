#ifndef IN_DSL
#ifndef _COMMON_DATALOG_
#define _COMMON_DATALOG_

#define ANY_OBJECT 0
#define NUM_SPECIAL_OBJECTS 1

#endif // #ifndef _COMMON_DATALOG_
#endif // #ifndef IN_DSL

#ifdef IN_DSL
    #include "Relations.datalog"

    var(x); var(y); var(z);

    object(x) <<= global(x);
    object(x) <<= function(x);
    object(x) <<= block(x);
    object(x) <<= instr(x);
    object(x) <<= mem(x);
    object(x) <<= pointer(x);
    object(x) <<= constant(x);
    object(x) <<= undef(x);
    object(x) <<= null(x);

    constant(x) <<= undef(x);
    constant(x) <<= null(x);

    pointer(x) <<= global(x);
    pointer(x) <<= function(x);
    pointer(x) <<= null(x);

    // no memory object for constant
    nonaddressable(x) <<= constant(x);

    // infer some types
    function(x) <<= hasArgument(x, _);
    function(x) <<= hasInstr(x, _);
    instr(x) <<= hasInstr(_, x);
    function(x) <<= hasBlock(x, _);
    block(x) <<= hasBlock(_, x);
    constant(x) <<= hasConstantField(x, _);
    constant(x) <<= hasConstantField(_, x);
    global(x) <<= hasInitializer(x, _);
    constant(x) <<= hasInitializer(_, x);

    // alias if two objects may points to the same thing
    alias(x, y) <<= pointsTo(x, z) & pointsTo(y, z);

    // reflexive-transitive closure
    pointsToIndirectly(x, x) <<= object(x);
    pointsToIndirectly(x, y) <<= pointsTo(x, y);
    pointsToIndirectly(x, z) <<= pointsTo(x, y) & pointsTo(y, z);

    // copy is reflexive and transitive
    // but NOT symmetric
    copy(x, x) <<= object(x);
    copy(x, z) <<= copy(x, y) & copy(y, z);

    // instruction predicates

    // instrAlloca(2) <-> 2 is an alloca instruction
    instr(x) <<= instrAlloca(x, _); // instrAlloca is an instruction
    hasOperand(x, y) <<= instrAlloca(x, y);

    // at of now, getelementptr is simply a copy instruction
    instr(x) <<= instrGetelementptr(x, _);
    hasOperand(x, y) <<= instrGetelementptr(x, y);

    instr(x) <<= instrLoad(x, _);
    hasOperand(x, y) <<= instrLoad(x, y);

    instr(x) <<= instrStore(x, _, _);
    hasOperand(x, y) <<= instrStore(x, y, _);
    hasOperand(x, y) <<= instrStore(x, _, y);

    instr(x) <<= instrRet(x, _);
    hasOperand(x, y) <<= instrRet(x, y);

    /**
     * The client should emit hasOperand relations
     * unknown instruction can do whatever possible to
     * its operands
     */
    instr(x) <<= instrUnknown(x);
#endif // #ifndef IN_DSL
